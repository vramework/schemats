import { Config, ConfigValues } from './config'
import { version } from '../package.json'
import { Database } from './schema-interfaces'
import camelcase from 'camelcase'
import { EnumTypes, TableDefinition } from './schema-interfaces'

const generateHeader = (config: Config, db: Database): string => {
    return `
/**
 * AUTO-GENERATED FILE @ ${new Date().toUTCString()} - DO NOT EDIT!
 *
 * This file was automatically generated by schemats v.${version}
 * $ ${config.getCLICommand(db.getConnectionString())}
 *
 */`
}

const reservedJSNames = new Set(['string', 'number', 'package'])
const normalizeName = (name: string): string => reservedJSNames.has('name') ? `${name}_` : name

export function generateEnum(config: Config, enumObject: EnumTypes): string[] {
    const enumStrings = []
    for (let enumNameRaw in enumObject) {
        const enumName = config.transformTypeName(enumNameRaw)
        if (config.enums) {
            enumStrings.push(`export enum ${enumName} {\n${enumObject[enumNameRaw].map((v: string) => `  '${camelcase(v, { pascalCase: true })}' = '${v}'`).join(',\n')} \n}`)
        } else {
            enumStrings.push(`export type ${enumName} = ${enumObject[enumNameRaw].map((v: string) => `'${v}'`).join(' | ')}`)
        }
    }
    return enumStrings
}

export function generateTableInterface(config: Config, tableNameRaw: string, tableDefinition: TableDefinition) {
    const tableName = config.transformTypeName(tableNameRaw)
    let members = ''
    const entries = Object.entries(tableDefinition)
    for (const [name, { tsType, nullable, isArray }] of entries) {
        const columnName = config.transformColumnName(name)
        members += `\n  ${normalizeName(columnName)}${nullable && config.config.optional ? '?' : ''}: ${tsType}${isArray ? '[]' : ''}${nullable ? ' | null' : ''}`
    }
    return `export interface ${normalizeName(tableName)} { ${members} \n}`
}

export const typescriptOfTable = async (config: Config, db: Database, schema: string, table: string, types: Set<string>) => {
    const tableTypes = await db.getTableTypes(schema, table, types)
    return generateTableInterface(config, table, tableTypes)
}

export const typescriptLookupForTables = (config: Config, tables: string[]): string => {
    const types = tables.map(t => `${t}: ${config.transformTypeName(t)}`)
    return `export interface Tables {
  ${types.join(',\n  ')}
}`
}

export const typescriptOfSchema = async (config: Config, db: Database): Promise<string> => {
    const schema = config.schema || await db.getDefaultSchema()
    const tables = config.tables || await db.getSchemaTables(schema)
    const enums = await db.getEnums(schema)
    const enumTypes = generateEnum(config, enums)
    const jsonTypesToImport = new Set<string>()
    const interfaces = await Promise.all(tables.map(table => typescriptOfTable(config, db, schema, table, jsonTypesToImport)))
    const output = [enumTypes.join('\n\n'), interfaces.join('\n\n')]

    if (config.typesFile && jsonTypesToImport.size) {
        output.unshift(`import { ${Array.from(jsonTypesToImport).join(', ')} } from '${config.typesFile}'\n\n`)
    }
    
    if (config.writeHeader) {
        output.unshift(generateHeader(config, db))
    }
    
    output.push(typescriptLookupForTables(config, tables))

    if (jsonTypesToImport.size) {
        output.push(`export type CustomTypes = ${Array.from(jsonTypesToImport).join(' | ')}`)
    }
    
    return output.join('\n\n')
}

export {
    Config,
    ConfigValues
}
